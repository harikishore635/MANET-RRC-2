═══════════════════════════════════════════════════════════════════════════
                    COMPLETE END-TO-END DATA FLOWS
═══════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│  FLOW 1: DOWNLINK - APPLICATION DATA TRANSMISSION (L7 → L2)             │
└─────────────────────────────────────────────────────────────────────────┘

[Application Process]
    │
    │ 1. User sends data packet
    │  typedef struct
        {
            uint8_t src_id;                     // Source node ID
            uint8_t dest_id;                    // Destination node ID
            RRC_DataType data_type;             // Data type for priority mapping
            TransmissionType transmission_type; // Unicast/Broadcast/Multicast
            uint8_t data[PAYLOAD_SIZE_BYTES];   // Actual data payload
            size_t data_size;                   // Size of data payload
            uint32_t sequence_number;           // Packet sequence number
            bool urgent;                        // Urgent/high priority flag //?
        } CustomApplicationPacket;
    │
    ▼
[MQ: APP→RRC]  (/mq_app_to_rrc)
    │
    │ Message: MSG_APP_DATA_PACKET
    │
    ▼
[RRC Process - App Message Handler Thread]
    │
    │ 2. rrc_app_message_handler() receives packet
    │
    ▼
    │ 3. rrc_process_application_packet()
    │    - Initialize FSM if needed (NULL→IDLE)
    │    - Check current state
    │    - Trigger connection setup if IDLE
    │
    ▼
    │ 4. process_custom_packet()
    │    - Get free message from pool
    │    - Copy packet data to ApplicationMessage
    │    - Map data type → priority (SMS → PRIORITY_DATA_3)
    │
    ▼
    │ 5. send_to_queue_l2_with_routing_and_phy()
    │    - FSM state check (must be IDLE or CONNECTED)
    │
    ├─────► [Query OLSR for next hop]
    │       │
    │       ▼
    │   [MQ: RRC→OLSR] (/mq_rrc_to_olsr)
    │       │
    │       │ Message: MSG_RRC_ROUTE_REQUEST
    │       │ typedef struct {
    │       │   uint8_t destination_node; // Destination node for route lookup
    │       │   uint32_t request_id;      // Unique request identifier
    │       │ } RRC_RouteRequest;
    │       │
    │       ▼
    │   [OLSR Process]
    │       │ olsr_layer_thread() dequeues RRC_RouteRequest from rrc_to_olsr_queue
    │       │ Calls: lookup_next_hop(destination) or get_next_hop(dest_id)
    │       │   - Looks up OLSR routing table (struct routing_table_entry)
    │       │   - If next hop disappears: triggers trigger_route_discovery(destination)
    │       │   - May call send_tc_message() to initiate topology control
    │       │   - Updates neighbor and topology tables as needed
    │       │
    │       ▼
    │   [MQ: OLSR→RRC] (/mq_olsr_to_rrc)
    │       │
    │       │ Message: MSG_OLSR_ROUTE_UPDATE
    │       │ typedef struct {
    │       │   uint32_t dest_id;     // Destination node
    │       │   uint32_t next_hop;    // Next hop node
    │       │   uint32_t metric;      // Path metric (e.g., ETX, hop count)
    │       │   uint8_t hop_count;    // Number of hops to destination
    │       │   bool available;       // Route availability
    │       │   uint32_t request_id;  // Original request ID
    │       │ } OLSR_RouteResponse;
    │       │
    │       │ OLSR fills OLSR_RouteResponse and enqueues to olsr_to_rrc_queue
    │       │
    │       ▼
    │   [RRC receives response]
    │       │ ipc_olsr_get_next_hop(dest) returns next_hop (calls lookup_next_hop internally)
    │       │
    ├───────┘
    │
    ├─────► [Query PHY for link quality]
    │       │
    │       ▼
    │   [MQ: RRC→PHY] (/mq_rrc_to_phy)
    │       │
    │       │ Message: MSG_RRC_METRICS_REQUEST {node_id=3}
    │       │
    │       ▼
    │   [PHY Process]
    │       │ - Check link metrics to node 3
    │       │ - RSSI=-75dBm, SNR=25dB, PER=5%
    │       │
    │       ▼
    │   [MQ: PHY→RRC] (/mq_phy_to_rrc)
    │       │
    │       │ Message: MSG_PHY_METRICS_UPDATE
    │       │ PHY_MetricsUpdate {rssi=-75, snr=25, per=5}
    │       │
    │       ▼
    │   [RRC receives metrics]
    │       │ is_link_quality_good() returns true
    │       │
    ├───────┘
    │
    │ 6. enqueue_to_appropriate_queue()
    │
    ├─────► [RRC Internal Slot Allocation - No IPC]
    │       │
    │       │ RRC owns all 10 slots (0-9):
    │       │ - Slots 0-3: VOICE priority
    │       │ - Slots 4-7: DATA priority
    │       │ - Slots 8-9: NC (Network Control)
    │       │
    │       ▼
    │   [Check Slot Availability]
    │       │
    │       │ rrc_check_slot_available(node_id=3, priority=PRIORITY_DATA_3)
    │       │ - Check tdma_slot_table[10] (RRC internal state)
    │       │ - Priority DATA_3 (value=4) → prefers slots 4-7
    │       │ - Find free slot in range 4-7
    │       │
    │       ▼
    │   [Allocate DU/GU Slot]
    │       │
    │       │ slot = rrc_allocate_du_gu_slot(node_id=3, priority=4)
    │       │ - Found: Slot 6 is FREE
    │       │ - Update tdma_slot_table[6]:
    │       │   • assigned_node = 3
    │       │   • is_tx_slot = true
    │       │   • priority = 4
    │       │   • last_update = timestamp
    │       │
    │       │ Result: allocated_slot = 6
    │       │
    ├───────┘
    │
    ├─────► [Send Slot Status Info to TDMA]
    │       │
    │       ▼
    │   [MQ: RRC→TDMA] (/mq_rrc_to_tdma)
    │       │
    │       │ Message: MSG_RRC_SLOT_STATUS_UPDATE
    │       │ SlotStatusInfo[8] {
    │       │   slot_id, node_id, is_allocated, is_tx_slot,
    │       │   traffic_type, priority (1=High, 2=Med, 3=Low)
    │       │ }
    │       │
    │       │ For each slot 0-9:
    │       │   - Slot 0-3: VOICE priority (High=1)
    │       │   - Slot 4-7: DATA priority (Med=2, Low=3)
    │       │   - Slot 8-9: NC control (High=1)
    │       │
    │       │ Example for allocated slot 6:
    │       │   SlotStatusInfo {
    │       │     slot_id = 6,
    │       │     node_id = 3,
    │       │     is_allocated = true,
    │       │     is_tx_slot = true,
    │       │     traffic_type = DATA_TYPE_SMS,
    │       │     priority = 3 (Low - PRIORITY_DATA_3)
    │       │   }
    │       │
    │       ▼
    │   [TDMA Process]
    │       │ - Receives slot status update
    │       │ - Updates local slot allocation table
    │       │ - Schedules transmission for allocated slots
    │       │ - Knows which queue to check for each slot
    │       │
    ├───────┘
    │
    ├─────► [NC Slot Allocation - For OLSR/Control Packets]
    │       │
    │       │ IF packet is OLSR HELLO/TC or NC control message:
    │       │
    │       │ nc_slot = rrc_assign_nc_slot(nodeID=source_node)
    │       │
    │       │ ┌────────────────────────────────────────────────┐
    │       │ │ HYBRID ALGORITHM: Seedex + Round-Robin        │
    │       │ └────────────────────────────────────────────────┘
    │       │
		changes:
			handle nc slot allocation for 32 nodes only and have rest for new node entry and time sync data 
    │       │ Step 1: Check Active Node Count
    │       │   IF activeNodeCount <= 40:
    │       │      → Use Round-Robin allocation
    │       │   ELSE:
    │       │      → Use Seedex deterministic
    │       │
    │       │ Step 2: Round-Robin Allocation
    │       │   candidate = (currentRoundRobinIndex % 40) + 1
    │       │   currentRoundRobinIndex++
    │       │   
    │       │   IF !rrc_is_nc_slot_conflicted(candidate, nodeID):
    │       │      → Assign NC slot = candidate
    │       │   ELSE:
    │       │      → Try Seedex algorithm
    │       │
    │       │ Step 3: Seedex Deterministic (Fallback)
    │       │   epoch = current_time / SUPERCYCLE_DURATION
    │       │   seed = (nodeID * epoch) % 999983
    │       │   
    │       │   FOR attempt = 0 to 5:
    │       │     candidate = (seed + attempt * 7) % 40 + 1
    │       │     IF !rrc_is_nc_slot_conflicted(candidate):
    │       │        → Assign NC slot = candidate
    │       │        → BREAK
    │       │
    │       │   IF still no slot:
    │       │      → Linear probe from (nodeID % 40) + 1
    │       │
    │       │ 

    │       │
    │       ▼
    │   [Send NC Slot Info to TDMA]
    │       │
    │       ▼
    │   [MQ: RRC→TDMA] (/mq_rrc_to_tdma)
    │       │
    │       │ Message: MSG_RRC_NC_SLOT_INFO
    │       │ 
    │       │ typedef struct {
    │       │   uint8_t activeNodes[MAX_MONITORED_NODES];  // Array of active node IDs
    │       │   uint8_t activeNodeCount;                   // Number of active nodes
    │       │   uint32_t supercycleCounter;                // Current supercycle count
    │       │   uint8_t currentFrame;                      // Current frame number
    │       │   uint8_t currentSlot;                       // Current slot number (8 or 9)
    │       │   uint8_t myAssignedNCSlot;                  // My assigned NC slot (1-40)
    │       │   OLSRMessage olsr_message;                  // OLSR HELLO/TC to transmit
    │       │ } NCSlotMessage;
    │       │
    │       │ Example:
    │       │   NCSlotMessage {
    │       │     activeNodes = {1, 3, 5, 7, 9, ...},
    │       │     activeNodeCount = 15,
    │       │     supercycleCounter = 42,
    │       │     currentFrame = 3,
    │       │     currentSlot = 8,                         // Physical NC slot
    │       │     myAssignedNCSlot = 12,                   // Logical NC slot 12/40
    │       │     olsr_message = {
    │       │       type = HELLO_MESSAGE,
    │       │       neighbors = [3, 5, 7],
    │       │       willingness = 3,
    │       │       htime = 2.0
    │       │     }
    │       │   }
    │       │
    │       ▼
    │   [TDMA Process]
    │       │ - Receives NCSlotMessage with OLSR data
    │       │ - Uses supercycleCounter/currentFrame for synchronization
    │       │ - When currentSlot matches myAssignedNCSlot mapping:
    │       │   • Transmits OLSR message in NC slot 8 or 9
    │       │   • Broadcasts HELLO/TC to all neighbors
    │       │ - Uses activeNodes list for network awareness
    │       │ - Schedules next NC transmission based on slot assignment
    │       │
    ├───────┘
    │
    │ 7. create_frame_from_rrc()
    │    - Build struct frame from ApplicationMessage
    │    - Set: src=1, dest=5, next_hop=3, TTL=10, priority=4
    │
    ▼
[Shared Memory Access - Queue Operations]
    │
    │ 8. sem_wait(&queue_mutex)  // Acquire lock
    │
    ▼
    │ 9. enqueue(&data_from_l3_queue[3], frame)
    │    - Priority 4 (PRIORITY_DATA_3) → queue index 3
    │    - Add frame to shared queue
    │
    ▼
    │ 10. sem_post(&queue_mutex)  // Release lock
    │
    ▼
[TDMA Process - Transmission Loop]
    │
    │
    │
    │ 12. IF TX slot ,Dequeue from the appropriate queue
    │
    ▼
[Shared Memory Access - Dequeue]
    │
    │ 13. sem_wait(&queue_mutex)  // Acquire lock
    │
    ▼
    │ 14. frame = dequeue(&data_from_l3_queue[3])
    │
    ▼
    │ 15. sem_post(&queue_mutex)  // Release lock
    │
    ▼
    │ 16. TDMA transmits frame over radio to node 3
    │
    ▼
[Physical Layer]
    │
    │ Frame transmitted wirelessly →→→
    │

┌─────────────────────────────────────────────────────────────────────────┐
│  FLOW 2: UPLINK - RECEIVED PACKET PROCESSING (L2 → L7)                  │
└─────────────────────────────────────────────────────────────────────────┘

[Physical Layer]
    │
    │ ←←← Frame received wirelessly from node 3 
    │
    ▼
[TDMA Process]
    │
    │ 1.when an interrupt from phy layer receive data from phy layer 
    │    frame {src=3, dest=1, next_hop=1, data="Reply"}
    │
    ▼
[Shared Memory Access - RX Queue]
    │
    │ 2. sem_wait(&queue_mutex)  // Acquire lock
    │
    ▼
    │ 3. enqueue(&rx_queue, frame)
    │
    ▼
    │ 4. sem_post(&queue_mutex)  // Release lock
    │
    ▼
[MQ: TDMA→RRC] (/mq_tdma_to_rrc)
    │
    │ Message: MSG_TDMA_DEQUEUE_REQUEST
    │ "New packet in rx_queue"
    │
    ▼
[RRC Process - TDMA Message Handler Thread]
    │
    │ 5. rrc_tdma_message_handler() receives notification
    │
    ▼
[Shared Memory Access - Dequeue RX]
    │
    │ 6. sem_wait(&queue_mutex)
    │
    ▼
    │ 7. frame = dequeue(&rx_queue)
    │
    ▼
    │ 8. sem_post(&queue_mutex)
    │
    ▼
    │ 9. rrc_process_uplink_frame(&frame)
    │    - Check if frame.dest_add == my_node_id (1 == 1) ✓
    │    - Check frame.rx_or_l3 flag
    │
    ├───► IF rx_or_l3 == true (L3 OLSR packet):
    │     │
    │     │ 10. forward_olsr_packet_to_l3()
    │     │
    │     ▼
    │ [MQ: RRC→OLSR] (/mq_rrc_to_olsr)
    │     │
    │     │ Message: MSG_OLSR_GENERIC_PACKET
    │     │ typedef struct {
    │     │   uint8_t msg_type; // OLSR message type: HELLO, TC, etc.
    │     │   uint8_t sender_id; // Originator node
    │     │   uint8_t payload[OLSR_MAX_MSG_SIZE]; // Raw OLSR message
    │     │   uint16_t payload_len; // Length of payload
    │     │ } OLSR_GenericPacket;
    │     │
    │     │ olsr_layer_thread() dequeues OLSR_GenericPacket from rrc_to_olsr_queue
    │     │ Calls: receive_message() → dispatches to process_hello_message(), process_tc_message(), etc.
    │     │   - Updates neighbor table (struct neighbor_entry)
    │     │   - Updates topology table (struct tc_entry)
    │     │   - May update routing table (struct routing_table_entry)
    │     │   - Handles duplicate detection (is_duplicate_message())
    │
    └───► IF rx_or_l3 == false (L7 Application data):
          │
          │ 10. deliver_data_packet_to_l7()
          │     - convert_frame_to_app_packet()
          │
          ▼
      [MQ: RRC→APP] (/mq_rrc_to_app)
          │
          │ Message: MSG_RRC_DELIVERY_STATUS
          │ APP_DataPacket {src=3, dest=1, data="Reply"}
          │
          ▼
      [Application Process]
          │
          │ 11. App message handler receives packet
          │     - Display to user: "Message from node 3: Reply"
          │
    │
    ├─────► [Check if should relay]
    │       │
    │       │  should_relay_packet(&frame)
    │       │    ├─ TTL > 0? (9 > 0) ✓
    │       │    ├─ dest != my_node? (5 != 2) ✓
    │       │    └─ Has route to dest?
    │       │       │
    │       │       │ IPC call to OLSR:
    │       │       │ next_hop = ipc_olsr_get_next_hop(dest=5)
    │       │       │ → OLSR returns next_hop = 3
    │       │       │
    │       │       └─ Route exists ✓
    │       │
    │       │ Result: RELAY NEEDED
    │       │
    ├───────┘
    │
    │  enqueue_relay_packet(&frame)
    │    ├─ Update next_hop via OLSR
    │    │  new_next_hop = ipc_olsr_get_next_hop(5) = 3
    │    │  frame.next_hop_add = 3
    │    │
    │    ├─ Decrement TTL
    │    │  frame.TTL = 8
    │    │
    │    └─ Enqueue to relay queue
    │       enqueue(&rrc_relay_queue, frame)
    │

┌─────────────────────────────────────────────────────────────────────────┐
│  FLOW 3: FSM STATE TRANSITIONS                                          │
└─────────────────────────────────────────────────────────────────────────┘

[RRC Process - Connection FSM]

    NULL
     │
     │ Power On
     ▼
    IDLE ──────────────────────┐
     │                         │
     │ Data Request            │ Inactivity Timeout
     ▼                         │
CONNECTION_SETUP               │
     │                         │
     │ Route + Slots OK        │
     ▼                         │
 CONNECTED ◄──┐                │
     │        │                │
     │        │ Reconfig OK    │
     │        │                │
     ▼        │                │
RECONFIGURATION                │
     │                         │
     │ Route Change            │
     └────────┘                │
     │                         │
     │ Release Request         │
     ▼                         │
   RELEASE                     │
     │                         │
     └─────────────────────────┘
                               │
                               ▼
                              IDLE

═══════════════════════════════════════════════════════════════════════════
                          KEY IPC MECHANISMS
═══════════════════════════════════════════════════════════════════════════

1. MESSAGE QUEUES (Control Path - Request/Response):
   ├─ Fast, non-blocking for control messages
   ├─ Small messages (route requests, slot checks, metrics)
   └─ Timeout handling for unresponsive processes

2. SHARED MEMORY (Data Path - High Throughput):
   ├─ Direct queue access by TDMA for metrics updates)
   ├─ NO slot allocation via IPC (RRC owns all slots internally
   ├─ Semaphore protection (queue_mutex)
   └─ Zero-copy for frame data

3. SYNCHRONIZATION:
   ├─ Single semaphore for all queue operations
   ├─ Request IDs match responses (prevents mixing)
   └─ Timeouts prevent deadlocks

4. ERROR HANDLING:
    ├─ Route not found → Trigger discovery
    │   olsr_layer_thread() calls trigger_route_discovery(dest)
    │   - Calls send_tc_message(&global_ctrl_queue) to broadcast TC
    │   - Calls send_hello_message() for neighbor discovery
    │   - Notifies RRC via OLSR_RouteResponse with available=true/false
   ├─ Slot not available → Notify application (failure)
   ├─ Link quality poor → Trigger reconfiguration
   └─ Process crash → Other processes continue

═══════════════════════════════════════════════════════════════════════════